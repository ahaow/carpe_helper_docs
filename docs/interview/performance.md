# 性能优化

## web 图片优化

### 名词解释

---

- **有损压缩:** 借由将次要的信息数据舍弃，牺牲一些质量来减少数据量，提要压缩比。这个过程是不可逆的。图片常见的有损压缩是合并相近的像素点
- **无损压缩:** 数据经过压缩后，信息不受损失，还可以完全恢复到压缩的样子。无损压缩一般通过两个步骤完成:

  1.  产生数据的统计模型
  2.  利用这个统计模型将较常出现的数据用较短的比特序列表示较不常出现的数据用较长的比特序列表示

- **索引色（Indexed Color）:** 一个字节 2^8 表示一个颜色，也就是最多支持 256 种颜色
- **直接色（Direct Color）:** 4 个数字表示一个颜色，分别表示红、黄、蓝以及透明度，所以最多可以表达 3^32 种颜色
- **位图（Bitmap）:** 又叫栅格图、点阵图，使用像素阵列来表示图像。位图就是由像素阵列的排列来实现其显示效果的，每个像素有自己的颜色信息，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、明度，从而改变图像的显示效果。位图根据位深度，有 1、4、8、16、24、32 位图像等。位图放大会失真变模糊。
- **矢量图：** 计算机图形学中用点、直线或者多边形等基于数学方程的几何图元表示图像。相比较位图，矢量图保存最少的信息，体积更小，缩放不会失真。
- **通道：** RGB 三种颜色信息称为红通道、绿通道、蓝通道，透明度事是 Alpha 通道。

### Web 中常用图片格式说明

---

- **JPEG/JPG :** 使用 JPEG 格式压缩的图片文件，是目前应用最广泛的图片格式之一。最普遍使用的扩展名格式为 .jpg，其他常用的扩展名还包括：.jpeg、.jpe、.jfif 以及 .jif。联合图像专家小组 1992 年发布的 JPEG 压缩标准，1994 年获得 ISO10918-1 认证。其特点是有损压缩，直接色，位图，体积最小，常用于颜色较为丰富、无透明要求的图片。

- **PNG：** PNG 是一种无损压缩的位图图形格式，支持索引、会读、RGB 三种颜色方案以及 Alpha 通道等特性。PNG 开发目标是改善并取代 GIF 作为适合网络传输的格式而不需要专利许可。使用场景是带有透明、半透明背景的图片，需要在网络传输中显示预览效果后展示全貌。上古时期 IE6 不支持 PNG 半透明，需要用 hack 方法解决。PNG 体积较大，非必需可用 JPG 替代。PNG 有 png8、png24、png32 之分。

  - png8：最多支持 256 色的 PNG，无损、索引色的位图。非动图可以替代 GIF，体积较小，透明度支持也更好。
  - png24：最多支持 2^24 色的 PNG，不支持透明，无损、直接色的位图。目标是替换 JPG，但一般来说，相同显示效果，PNG 图片是 JPG 体积的数倍。
  - png32：加上 8 位 Alpha 通道的 png24.

- **GIF：** 图像互换格式是一种位图图形文件格式，无损压缩、索引色。原始版本为 87a，1989 年发布 89a 版本，支持多帧动画和透明色。1995 年网景 2.0 发布，定义了动画循环多少次或是否无限次播放，现在聊天的动图都是基于该版本的 GIF。GIF 的特性如下：

  - 优秀的 LZW 算法在保证质量的同时将体积变得更小
  - 可插入多帧实现动画效果
  - 可实现透明效果
  - 最多支持 256 色，故不适用于真彩色图片

- **WebP：** 谷歌 2010 年发布的同时支持有损和无损压缩的图片文件格式。有损用来替代 JPG，无损用来替代 PNG，动态用来替代 GIF。根据谷歌较早前的测试，WebP 的无损压缩比网络上找到的 PNG 少 45% 的文件大小，即使这些 PNG 已经使用 Pngcrush 和 PNGOUT 处理过，WebP 还是可以减少将近 30% 的文件体积。WebP 目前还不能全平台兼容，相关兼容性可在此[链接](https://caniuse.com/#feat=webp "opens new window")查看。

- **svg：** 可缩放矢量图形是一种基于可扩展编程语言（XML），用于描述二维矢量图形的图形格式。SVG 由 W3C 制定，是一个开放标准。SVG 的优点是文件可读，易于修改编辑，支持多种滤镜和特殊效果，在不改变图片文件的前提下可实现位图种类似图片阴影的效果，还可以生成动态图形

### 拥抱 HTTP2

---

更快、更简单、更稳定是我们每个前端工程师的追求，HTTP/2 的出现让这些美好的词汇都会聚在一起

#### 二进制分帧层

HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务端之间传输。

HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有的传输的信息分割为更小的消息和帧，并采用二进制格式对它们进行编码

#### 服务端推送

一般情况下，客户端需要什么东西会告诉服务端，然后服务端返回对应的资源到客户端。HTTP/2 新增的另一个强大的功能是服务端可以对一个客户端请求发送多个响应。换句话说，服务端可以先于客户端检测到将要请求的资源，提前推送到客户端，不发送所有资源的实体，只发送资源的 URL。客户端接到后会进行验证缓存，如果发现需要这些资源，则正式发起请求。

#### 标头压缩

每个 HTTP 传输都承载一组标头，这些表头说明了传输的资源以及属性。在 HTTP/1.x 中，这些元数据始终以纯文本形式，通常会给每个传输增加 500 - 800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提高性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：

1. 支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小；
2. 客户端和服务端之间同时维护和更新一个包含之前见过的标头字段的索引列表（换句话说，它可以建立一个共享的压缩上下文），对相同请求而言不需要再次发送和响应，比如 User-Agent

在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段均为小写，请求行现在拆分为各个 `:method`、`:schema`、`:authority` 和 `:path` 伪标头字段。

#### 多路复用

每个 TCP 连接智能发送一个请求，HTTP/1.x 在前面的请求没有完成前，后面的请求将会阻塞。

其实在 HTTP/2 之前，我们在写代码的时候也用过类似的思想，比如：

1. 合并 CSS 和 JS 代码
2. 雪碧图
3. Iconfont

HTTP/2 的出现又让我们省掉不少麻烦。多路复用允许同时通过单一 HTTP 请求多个响应

### 少不了的懒加载

---

#### 什么是懒加载

只加载可视区的内容，当页面向下滚动的时候，再加载后面的内容。

图片懒加载的原理非常简单，我们先不设置图片的 src 属性，将图片的真实路径放在一个浏览器不认识的属性中（比如 data-src），然后我们去监听 scroll 事件。当页面的 scrollTop 与浏览器的高度之和大于图片剧页面顶端的 Y 时，说明图片已经进入可视区域，这时把 data-src 放到 src 中即可。

#### 为什么要使用懒加载？

1. 对于大多数用户，特别是移动端和网速比较差的用户，如果首屏加载过多的图片，页面将会加载得很慢而且浪费用户的流量；
2. JavaScript 脚本通常要等到 DOM 加载完成后才会执行，如果加载的资源过多，可能会影响网页的正常使用；
3. 能够节省流量和减轻服务器压力，进一步为公司减少成本。

#### 如何实现

社区成熟的轮子比比皆

### 正确使用缓存

---

缓存是一种保存资源副本并在下次请求是直接使用该副本的技术，因此使用 HTTP 缓存是 WEB 性能优化中必不可少的，也是每位前端工程师的必修课

浏览器和服务器之间使用的缓存策略可以分为 强缓存、协商缓存 两种：

- 强缓存：在缓存数据为失效的情况下，不需要再和服务器发生交互
- 协商缓存：需要与服务器校验是否使用缓存

#### ETag

有这样一种场景，浏览器检查本地缓存找到之前响应的文件已经过期，只能去服务端请求。但是服务器的资源没有发生变化，可以说是浪费了一次请求。

ETag 的出现很好地解决了这个问题，其为一个哈希值，浏览器甚至不用去关心这个值是怎么来的。在第一次请求时，服务器对资源生成一个 ETag 并返回给浏览器，浏览器下次请求后会自动在 `If-None-Match` HTTP 请求头内提供 ETag, 服务器根据这个哈希值 与 服务器本地对应资源当前的哈希值进行比对，如果它未发生变化，服务器将返回 `304 Not Modified`相应，这样一个来回避免了浏览器再次去请求资源，省钱又省时间

#### Cache-Control

Cache-Control 是强缓存的一种，每个资源都可以通过 Cache-Control 定义其缓存策略，Cache-Control 来控制谁可以缓存，缓存多久

无需和服务端通信的请求是最佳的，通过本地副本消除所有网络延迟，节省流量

| 指令     | 说明                                                                 |
| -------- | -------------------------------------------------------------------- |
| max-age  | 指令指定从请求的时间开始，允许提取的响应被重用的最长时间（单位：秒） |
| private  | 只为单个用户缓存，不允许任何中间缓存对其进行缓存                     |
| no-cache | 先与服务器确认返回的响应是否发生了变化，走协商缓存                   |
| no-store | 禁止浏览器以及所有中间缓存存储任何版本的返回响应                     |

#### 缓存 CheckList

实际开发中往往不存在什么固定的最优解，我们需要根据不同的业务场景制定相应的策略

- **变与不变:** 一些不变的部分，如第三方库的代码，可以考虑和业务代码分离，这样一来可以减少下载资源的大小
- **最佳的缓存周期:** 不同的资源可能有不同的更新要求，设置合适的 max-age
- **ETag:** 当服务器上的资源未变动时无需请求

### 雪碧图

---

雪碧图是一种 CSS 图像合成技术，主要用于小图片显示

#### 使用场景

在网页中，为了更好的展示效果，通常会采用一些小图标来替代文字。通常的方式包括 IconFonts、SVG Icons、小图片。其中 Icon Font 支持单色，SVG Icons 需 IE9+。

如果采用小图片，需要考虑一个问题：每张小图片独立请求，加载时都会产生一个 http 请求，而小图片的体积甚至比 http 请求头等结构的体积还要小，显得非常没有必要， 所有我们通常会将所有的小图片合并成一张图片请求

#### 实现原理

将小图标合并成一张图片，利用 `background-position` 属性值来确定图片呈现的位置

#### 自动生成

每次修改或新增图片，都需要对雪碧图进行修改，如果依靠人工维护，成本太高，所以我们使用`spritesmith`，它可以自动合并图片，并得到图片在合并后的相对位置

```js
const fs = require("fs");
const path = require("path");
const Spritesmith = require("spritesmith");

const baseDir = "./images";
const files = fs.readdirSync(baseDir);
const sprites = files.map((file) => path.join(baseDir, file));

Spritesmith.run({ src: sprites }, (err, result) => {
  if (err) {
    console.error(err);
  } else {
    console.info(result);
  }
});
```

运行的输出结果如下：

```js
{
  coordinates: {
    'images/alipay.png': { x: 0, y: 131, width: 81, height: 73 },
    'images/taobao.png': { x: 177, y: 0, width: 114, height: 114 },
    'images/wechat.png': { x: 0, y: 0, width: 177, height: 131 },
    'images/xinlang.png': { x: 81, y: 131, width: 72, height: 72 }
  },
  properties: { width: 291, height: 204 },
  image: <Buffer 89504e 470d 0a 1a 0a 0000000d 4948445200000123000000 cc 08060000003845 c5 ce 00004006494441547801 ec c1 0b 98 e6 0561 ... 22705 more bytes>
}
```

其中：

- `coordinates`：每张图片对应的尺寸和位置
- `properties`：生成的图片尺寸
- `image`：文件的 Buffer，可用于生成图片

对于现有的常用的构建工具，已有现成的插件可直接使用：

- webpack-spritesmith
- gulp.spritesmith
- grunt-spritesmith

#### 注意事项

1. 如果要适配高清屏，需要配置高清屏的图片，并且通过设置`background-size`属性来使得最终显示正常，可参考以上插件的`retina`相关配置参数；
2. 由于 HTTP/2 的支持多路复用特性，使得单个图片的请求的开销很小，不推荐使用雪碧图了，但为了兼容 HTTP1.1，现阶段多版本 HTTP 协议并存期间还是建议保留
3. 雪碧图好用，可不要滥用。可参考以上插件的`retina`相关配置参数；

### IconFont

---

IconFont 叫做字体图标，即通过自体的方式展示图标，多用于渲染图标、简单图形、特殊字符等

使用 IconFont 时，只需要引入对应的字体文件，针对加载图片张数较多的情况，可以有效减少 HTTP 请求次数，而一般字体体积较小，所以请求传输数据量较少。与直接引入图片不同，IconFont 可以像使用字体一样，设置大小和颜色，还可以通过 CSS 设置特殊样式，且因为是矢量图，不存在失帧的情况。

> 根据开发需求，按需引入不同格式的字体文件（eot / ttf / woff/ svg）

```html
<style>
  @font-face {
    font-family: "iconfont";
    src: url('iconfont.eot'); /* IE9*/
    src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
         url('iconfont.woff') format('woff'),
         url('iconfont.ttf') format('truetype'), /* chrome, firefox, opera, Safari,  Android, iOS 4.2+*/
         url('iconfont.svg?#iconfont') format('svg'); /* iOS 4.1- */
  }

  .iconfont {
    font-family: "iconfont";
  }
</style>

<body>
  <!-- &#xe609 是一个字符的 unicode 码，在该 iconfont 字体文件中对应某个图标 -->
  <i class="iconfont">&#xe609</i>
</body>
```

### Base64

Base64 是网络上最常见的用于传输 8Bit 字节码的编码方式之一，可将图片编码为特定的字符串，由 52 个大小字母和 10 个数字，以及 +、/、= 三个字符组成。

使用 Base64 编码渲染图片有以下优点：

1. 有效减少 HTTP 请求次数
2. 可对数据进行简单加密，无法肉眼获取信息
3. 没有跨域问题，无需考虑图片缓存

缺点：

- 编码后文件体积增大，仅适用于小体积图片编码
- 增加了编码和解码的工作量
- 不支持 IE8 以下版本

如需将图片转换为 Base64 编码，可以使用原生 API `FileReader.readAsDataURL`

### 图片体积优化

---

图片体积压缩就是在图片保持可接受的清晰度范围内同时减少了文件大小，图片体积压缩可以借助工具实现

#### 在线工具

- TinyPNG：免费，TinyPng 使用智能有损压缩技术减小 PNG 文件的文件大小，原理是将图片中相似的颜色组合起来（量化），通过减少颜色的数量，可以将 24 位 PNG 文件转为更小的 8 位索引图片，同时所有不必要的元数据被剥离。

- 智图：免费，可以选择压缩质量，生成 Webp。

- Iloveimg：免费，支持压缩 JPG，PNG， GIF， 能保持最佳文件质量和压缩程度, 并且 Iloveimg 不仅仅是一款图片压缩工具，还支持图片的裁剪、图片的格式转换以及大小调整等功能。

#### 客户端工具

- PhotoShop：只适用 JPG，导出时选择 JPG，选择压缩质量。

#### 阿里云 OSS

[地址](https://help.aliyun.com/document_detail/44688.html)

### 图片格式

---

| 类型 | 动画   | 压缩类型            | 浏览器支持                            | 透明度 |
| ---- | ------ | ------------------- | ------------------------------------- | ------ |
| GIF  | 支持   | 无损压缩            | 所有                                  | 支持   |
| PNG  | 不支持 | 无损压缩            | 所有                                  | 支持   |
| JPEG | 不支持 | 有损压缩            | 所有                                  | 不支持 |
| webP | 不支持 | 无损压缩 / 有损压缩 | Chrome、Opera、Firefox、Edge、Android | 支持   |

### 多倍图

---

在 Retina 视网膜屏幕面试之前人们很少关注像素密度和设备像素比，随着 Retina 屏在移动设备中越来越广泛使用，为了保证图片在不同 DPR（设备像素比）的设备上显示足够清晰，开发者需要针对不同设备适配不同倍数的图片。

**像素相关概念**

- DP: 设备像素，又名物理像素，即设备屏幕上真实的物理像素，以矩阵的形式排列
- DIP: 设备无关像素，是一种基于屏幕坐标的抽象像素，应用程序以抽象像素为单位，如 CSS 中的单位 px，实际渲染是通过底层程序转换为物理像素
- DPR: 设备像素比，设备像素 / 设备无关像素，在 JS 中可以通过 `window.devicePixelRatio` 获取

**多倍图概念**

- 在 DPR 为 1 的设备中，使用 1\*1 个物理像素展示一个 CSS 像素
- 在 DPR 为 2 的设备中，使用 2\*2 个物理像素展示一个 CSS 像素
- 在 DPR 为 3 的设备中，使用 3\*3 个物理像素展示一个 CSS 像素

**自适应 DPR 加载图片**

在高分辨率显示屏如 2x 上，在页面中使用二倍图可以保证清晰度，但是当此页面在低 DPR 设备打开时，我们只需要 50% 长宽的图片就能保证显示效果，而此时带宽开销却是一样的。所以为了节约传输流量，我们需要告诉浏览器，根于不同的 DPR 加载不同尺寸的图片，通常有以下三种方法：

1. 使用 picture 标签，除了 IE，现有主浏览器均已支持该标签

```html
<picture>
  <source srcset="photo@3x.jpg" media="(min-width: 800px)" />
  <source srcset="photo@2x.jpg" media="(min-width: 600px)" />
  <img srcset="photo.jpg" />
</picture>
```

2. 使用 img srcset 属性，除了 IE，现有主浏览器均已支持该属性

```html
<img src="photo.png" srcset="photo@2x.png 2x, photo@3x.png 3x" alt="photo" />
```

3. 使用 CSS3 img-set 函数，兼容性相较于前两者较差

```css
* {
  background-image: image-set(
    "photo.png" 1x,
    "photo@2x.png" 2x,
    "photo@3x.png" 3x
  );
}
```

### 设置 alt 属性

---

最基础的方式，是装饰性图片归类到背景图，通过 CSS 背景图进行设置；功能性图片放到 HTML 中，通过 `img` 标签引入，且要设置 `alt` 属性，以便被屏幕阅读器识别并阅读。图片 `alt` 信息应简短，介绍图片信息即可，避免内容冗余。图片的长信息介绍应被放到 `longdesc` 属性中：

```html
<img src="" alt="图片说明" />
<img
  src=""
  longdesc="一段很长的文字一段很长的文字一段很长的文字一段很长的文字"
/>
```

- 宽或高不到 8px 或者没有 alt 的图片（特别是装饰性的图片）应该被移除，CSS 技术可以用来控制样式
- alt 是用来描述图片的，而非单纯的新闻标题或者名词
- alt 属性不应包含图片的文件名
- alt 值不应包含冗长的信息（如果很长可以使用）
- 每个 img 标签要应该设置 alt 属性
- 不能只依赖图片上的文字信息
- Banner、头图上的文字信息必须在代码中有所体现

### 考虑 IMG Sprite

---

“高对比度模式” 是一种 Windows 系统的设置主题，其用意是为了保证视力受损的用户，在查看 Web 信息时提供方便。它通过使用对比鲜明的色彩和字号来提高文本的可读性，高对比度模式下网页的背景默认会变成全黑。

CSS Image Sprites（CSS 雪碧图）是一项用来减少网页中图片 HTTP 请求数的技术，但其会导致在 Windows 高对比度模式下背景图片消失，其服务的 Web 应用性能的提升和对无障碍体验被破坏之间的矛盾，已经引起了 Web 开发者的关注。Sprite 技术的使用的确为更多网站的优化加载速度的体验贡献甚大，但我们要承认，这个过程中我们忽略并损害了使用高对比度模式用户的体验。由于 <img> 元素可以在高对比度模式下显示，故而在此场景下，使用基于 <img> 标签的 Sprite 技术，可以得到比基于 CSS 背景图的 Sprite 更多的收益。

### 总结

---

就前端性能优化而言，图片优化可谓是其必不可少的环节。但是与其说是在做优化，不如说是在做“权衡”。一些操作是以牺牲一部分成像质量为代价的。我们的主要任务，是尽可能的去寻求一个质量与性能之间的平衡点，并在不同业务场景下，做好图片方案的选型工作。

## 异步加载

### 异步加载的方式

---

1. defer
2. async

### 异步加载的区别

---

1. defer 是 html 解析完才会执行，如果是多个，按照加载的顺序依次执行. defer 脚本会在`DOMContentLoaded` 和 `load` 事件之前执行
2. async 会在脚本加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。async 会在 load 事件之前执行，但并不能确保和`DOMContentLoaded`的执行先后顺序

## 性能优化方案

### 问题分析

---

优化方向有两个：

1. HTTP 请求
2. JS 加载

打开浏览器控制台的网络，可以看到从拉去模板开始到首次渲染中间到底加载了什么，如果中间某些资源加载速度过慢，则可以从方面入手，否则的话有可能是解析 js 速度过慢导致

### 请求优化

#### 合理使用缓存

合理使用缓存，降低请求等待的时间，可以通过达到性能要求

#### CDN 内容分发

将非核心的资源通过 CDN 的方式进行分发，例如使用第三方库，可以有效减少包的体积，同时稳定高速的 CDN 服务器也可以加快请求的速度

CDN 通常会配合异步加载一起使用

#### 图片优化

使用合适的图片格式作为网站的图片，比如 WebP，具体看图片优化

#### HTTP/2

随着时间的推移，迁移到 HTTP/2 是不可避免的。目前浏览器对于 HTTP/2 的支持度都非常友好，同时相对于 HTTP/1, HTTP/2 在性能上有着非常显著的提升

#### 资源压缩

目前浏览器大多都支持对压缩资源进行加载，比如 js, css 的 gzip，开启压缩后，会让资源的体积减小，从而降低请求时间

### 加载优化

---

#### 将 CSS 放在文件头部，JS 放在文件底部

CSS 和 JS 都会阻塞 HTML 的渲染，如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。

所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。

但是为什么 CSS 还是要放在头部呢？ 因为如果先加载 HTML，再加载 CSS，会让用户第一时间看到的页面是 没有样式的，丑陋的，为了避免这种情况，所有要将 CSS 放在文件头部

#### 拆包

在不配置拆包的情况下，Webpack 会将所有的资源都打包在一个 js 文件中，这无疑会让请求时候的响应体积变得非常大，从而降低加载速度

同时，不配置拆包，会在首次加载的时候加载一些无关的资源，浪费一次宝贵的请求

合理配置拆包，让每次请求都只请求对应的核心资源，从而达到按需加载的程度

拆包通常的逻辑：

1. 业务代码和第三方依赖进行拆解
2. 对于第三方依赖：

- 将版本经常变的与版本不怎么变动的进行拆分
- 版本不怎么变动的依赖可以合理配置 CDN

3. 对于业务代码

- 将业务模块和公共模块进行拆分
- 业务模块也根据调用的次数进行拆分
- 将首屏模块单独进行拆分

#### 异步加载

非核心的资源不需要再拉去模板之后立马就加载，可以使用异步加载，让这些非核心资源在视图构建完毕以后再进行加载。

#### 预加载

与首屏优化一样，路由跳转优化也是非常关键。我们可以通过判断是否需要进行路由跳转，在跳转之前做一些提前加载，从而达到跳转完成之后，资源立马加载完成之后，资源立马加载完毕的效果从而提升加载速度。

#### 合理配置打包版本

首先我们需要明确一点，一般情况下，随着新标准的制定，浏览器厂商通常会着重对新标准的性能进行优化，而老标准的优化频率会慢慢降低，所以，我们编码的目标便是面向未来编程。

另外，目前我们主要是用 ES6+ 或 TS 进行编码，经过打包工具构建之后，性能往往比不上手写的代码，虽然随着工具的升级，性能会越来越好，但是编译后的代码，尤其是对 class 代码的编译，性能下降是非常明显的。

最后，编译后代码的体积会出现膨胀的情况，编译器使用了很多技巧来将 es6 转换成 es5，所以使用 es6 版本会让体积更小。

目前主流浏览器对于 ES6 的支持越来越好，打包的时候可以设置两个构建，对于支持度较好的浏览器版本，使用更高级的版本，从而达到减小包的体积来达到更快的加载速度。

同时，可以使用 `<script type="module"></script>` 的方式来实现动态加载 es6 代码，详情可以查看随着 Vue3 一起发布的 Vite。

#### 多线程

现代浏览器大都支持`Worker`, 这是一种浏览器实现多线程的方式，他可以与 JS 线程，GUI 线程同时运行，通过 Worker，我们可以将一些复杂繁琐的操作交给子线程来完成，从而避免渲染线程的阻塞，来达到性能的优化

但是，线程之间的通信是需要消耗时间的，所以多线程技术应该合理地使用。

#### 使用外链样式而非内联样式

浏览器对于外链样式处理的速度会比内联样式更快，这也是为什么`style-components`这么火的原因。

同时优先使用浏览器的 html 标签 link, 而不是 css 中的 @import， 原因在于 link 的加载是和 GUI 线程并行的，但是 @import 需要等待 HTML 完全处理完成之后再进行加载

### 体验优化

---

#### 骨架屏

使用 loading 图 或者 骨架屏，可以一定程度上减少用户等待加载的焦虑感，让用户感觉没有等太久，这就是用户体验级的优化

#### 服务端渲染

在条件允许的情况下，将客户端渲染迁移到服务端渲染，利用服务端高性能的表现，可以实现用户拉去到模板之后立马显示视图，省去中间 js 加载的过程。

#### 动画

直接操作 DOM, 有可能会引起大面积的重绘和重排，从而引起掉帧的情况，导致用户体验下降

合理使用 CSS3 GPU 加速，可以避免使用动画之后的重排和重绘，达到更流畅的动画效果

有一说一，开启 CSS3 GPU 加速是非常消耗功耗的，所有在移动端上面谨慎使用

#### 虚拟滚动

我们知道，页面进行滚动的时候，也会触发浏览器的重排，如果此时前端需要渲染大量数据，而且还不允许分页，这种情况下会导致浏览器的掉帧、卡顿甚至假死的情况。

这种情况下，如果不能使用分页进行优化，通常我们会使用虚拟滚动的方式来解决问题。

因为 DOM 元素的创建和渲染需要的时间成本很高，在大数据的情况下，完成渲染列表所需要的时间不可接受，所以我们可以只渲染可视区域，从而达到极高的初次渲染性能。

## 浏览器缓存

### 强缓存

浏览器检查强缓存的方式主要有两个字段：

- HTTP/1.0 时期使用`Expires`
- HTTP/1.1 时期使用`Cache-Control`

#### Expires

Expires 字面意思是有效期， 所以它表示的是一个具体的时间，例如：

```md
Expires: Wed, Nov 11 2020 08:00:00 GMT
```

表示的是这个资源将在 2020 年 11 月 11 日 8 点过期，过期就得重新向服务端发送请求

很有意思的是，通常情况下服务端的时间与客户端的时间其实是并不一致的，那么如果设置了 Expires 字段就很有可能造成缓存失效，因此这种方式并不准确，所以在 HTTP/1.1 被放弃了

#### Cache-Control

放弃了 `Expires` 之后，HTTP1.1/采用了`Cache-Control`这个重要规则，它设置了一个具体的过期时长，其中的一个属性是 max-age

```md
Cache-Control: max-age=300
```

表示当前资源会在 300s 后过期

`Cache-Control` 不仅仅含有一个 `max-age` 的属性, 它还有很多用法，甚至还可以采用组合的方式：

```md
Cache-Control: public, max-age=300
```

下面列举一些常用指令：

1. public: 客户端和代理服务器都可以缓存，响应可以被中间任何一个节点缓存
2. private: 这个是 `Cache-Control` 的默认值，只有客户端可以缓存，中间节点不允许缓存
3. no-cache: 表示不进行强缓存验证，而是用协商缓存来验证
4. no-store: 所有内容都不会被缓存，既不使用强缓存，也不使用协商缓存
5. max-age: 表示多久时间之后过期
6. s-max-age: 作用同 max-age，但是表示代理缓存，且优先级更高
7. max-stale: 能容忍的最大过期时间
8. min-fresh: 能容忍的最小新鲜度

**对比**

1. Expires 产于 HTTP/1.0, 而 Cache-Control 产于 HTTP/1.1
2. Expires 设置的是一个具体的时间，Cache-Control 可以设置除时间以外的其他属性
3. 两者同时存在时，Cache-Control 优先级更高
4. 在不支持 HTTP/1.1 的环境下，Expires 就会发挥作用，所以现阶段的存在是为了做一些兼容处理

### 协商缓存

上面我们介绍了强缓存， 如果强缓存失效， 则会进入协商缓存

协商缓存概括起来就是浏览器会携带缓存标识(tag)向服务器发送请求，服务端会根据缓存标识(tag)来决定是否使用缓存

所以对于服务器来说，返回的结果会有两种：

- 协商缓存生效，返回 304 状态码 和 `Not Modified` (空的响应体)
- 协商缓存生效，返回 200 和 请求结果

协商缓存分为 `Last-Modified` 和 `ETag` 两个字段控制

#### Last-Modified 和 If-Modified-Since

从字面意思上可以看出，`Last-Modified`表示的是资源最后的修改时间，它的实现方式是：

1. 浏览器第一次向服务器请求该资源
2. 服务器在返回这个资源的同时，会在响应头添加`Last-Modified`的字段，值为最后的修改时间
3. 当浏览器接收后缓存文件和这个 header
4. 当下一次浏览器再次发送请求，请求该资源的时候，检测到有`Last-Modified`这个 header, 就会在请求头中添加`If-Modified-Since`这个字段，值为`Last-Modified`
5. 服务器接收到请求之后，根据`If-Modified-Since`与服务器的这一资源的最后修改时间做对比
6. 如果结果相同，则返回 304 状态码和一个空的响应体，告诉浏览器使用缓存
7. 反之，返回 200 状态码和请求资源，同时在响应头中更新`Last-Modified`

#### ETag 和 If-None-Match

Etag 的原理其实和 Last-Modified 相似，但是它是根据一个唯一标识来进行判断

当浏览器请求服务器资源的时候，服务器会根据当前文件的内容，给文件生成一个唯一的标识，若是文件发生修改，则标识也会修改。

服务器在响应请求的时候，会在响应头添加一个 ETag 的字段，值为这个文件当前的唯一标识。

浏览器在接收到文件并缓存文件和请求的响应头

在下一次请求这个资源的时候，浏览器会在请求头上加一个 If-None-Match 的字段，值为 ETag

服务器用请求头上的值和本地资源的值进行对比，如果命中则返回 304 告诉浏览器使用本地缓存，否则返回 200 和最新资源文件

#### 两者对比

首先对于 Last-Modified:

- 若是本地打开了缓存，并且并没有修改文件，也还是会改变最后的修改时间，导致缓存失败；
- 由于 `Last-Modified`是以秒作为计时单位，若是某个文件的改动是在秒级以内的话，那么这之后是无法被记录导致缓存命中错误

对于 ETag:

- 性能上会比 Last-Modified 差，只要文件发送修改，就会重新生成一个新的 Hash 值。

综上：

- 准确度上，ETag 要高于 Last-Modified
- 性能上 Last-Modified 更好
- 两者都支持的话， ETag 优先级更高

### 缓存位置

在上面 👆🏻 已经介绍了缓存的类型 😁， 但是之前也提到了，若是命中了 **强缓存** 或者服务器返回了 `304` 之后，要浏览器从缓存中获取资源，那这些缓存具体存储在哪里呢？

从优先级来说，缓存位置分为以下四种:

1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

### Service Worker

Service Worker 是运行在浏览器背后的独立线程，也就是说它脱离了浏览器的窗体，无法直接访问 DOM

功能上主要能实现：离线缓存，消息推送，网络代理等。 比如离线缓存就是 **Service Worker Cache**

- 借鉴了 Web Worker
- 使用 Service Worker 会涉及请求拦截，所以需要用 HTTPS 协议来保证安全，传输协议必须是 HTTPS
- 与浏览器其他内建的缓存机制不同，它可以让我们自由的控制缓存那些文件，如何匹配读取缓存，且缓存是持续性的
- Service Worker 同时也是 PWA 的重要实现机制

### Memory Cache

内存缓存， 存储的主要是当前网页上已经抓取到的资源，比如网页上已经下载的样式、脚本、图片等

Memory Cache 的特点是：

1. 读取率高，但是持续时间短，会随着进程的释放而释放（一旦关闭 Tab 页面就会被释放，甚至有时候没关闭前，排在前面的缓存就已经失效了）
2. 几乎所有的请求资源都能进入 Memory Cache， 细分来说主要分为 `preloader` 和 `preload` 这两块
3. 在从 memory cache 读取缓存时，浏览器会忽视 `Cache-Control` 中的一些 max-age、no-cache 等头部设置，除非设置了 no-store 这个头部设置

#### preloader

上面提到的 `preloader` 是页面优化的常见手段之一，它的主要作用是: 在浏览器打开一个网页的时候，能够一边解析执行 js/css， 一边去请求下一个资源，而这些被 preloader 请求的资源就会被放在 memory cache 中，供之后的解析执行操作使用。

#### preload

preload 和 preloader 长得非常相似， 它能够显式指定预加载的资源，这些资源也会被放进 memory cache 中

例如：

```html
<link rel="preload" />
```

### Disk Cache

Disk Cache 也叫 HTTP Cache，是存储在硬盘中的缓存，所以它的特点是持续时间长，是实际存在于文件系统的缓存

从存储效率来说，它比内存缓存慢，但是优势在于存储容量大，持续时间更长

在所以浏览器缓存中，Disk Cache 是覆盖面最大的，它会根据前面我们提到的 HTTP header 中的缓存字段来判断哪些资源需要缓存，哪些资源不需要请求而直接使用，哪些已经过期了需要重新请求获取

若是命中缓存之后，浏览器会从硬盘中直接读取资源，虽然没有从内存中读取快，但是仍然比网络下载快

前面提到的强缓存和协商缓存也是属于 Disk Cache， 它们最终都存储在硬盘里

Disk Cache 和 Memory Cache 之间的对比：

1. 比较大的 JS、CSS 文件会被丢在硬盘中存储，反正则存储在内存中
2. 当前系统内存使用率比较高的时候，文件优先进入硬盘

### Push Cache

Push Cache(推送缓存), 它是浏览器缓存的最后一道防线，当以上三种缓存都没有命中的时候，它才会被使用

它只会在会话(Session)中存在, 一旦会话结束就会被释放，并且缓存时间非常短，在 Chrome 浏览器中只有 5 分钟

另外由于它是 HTTP/2 的产物，所以国内普及程度不高，这里贴上一个总结：

1. 所以的资源都能被推送，并且能够被缓存，但是 Edge 和 Safari 支持相对比较差
2. 可以推送 no-cache 和 no-store 的资源
3. 一旦连接被关闭，Push Cache 就会被释放
4. 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache，这主要还是依赖浏览器的实现，出于性能的考虑，有些浏览器会对相同域名但不同 tab 标签使用同一个 HTTP 请求
5. Push Cache 中的缓存只能被使用一次
6. 浏览器可以拒绝接收已经存在的资源推送
7. 你可以给其他域名推送资源

### 缓存过程分析

上面已经介绍了缓存类型和缓存位置，那么浏览器是如何处理缓存?

从浏览器发起 HTTP 请求到获取请求结果，可以分为以下几个步骤：

1. 浏览器第一次发起 HTTP 请求，在浏览器缓存中没有发现缓存结果和缓存标识
2. 因此向服务器发起 HTTP 请求，获取该请求的结果以及缓存规则(也就是 Last-Modified 或者 ETag)
3. 浏览器把响应内容存入 Disk Cache, 把响应内容的引用存入 Memory Cache
4. 把响应内容存入 Service Worker 的 Cache Storage(如果 Service Worker 的脚本调用了 cache.put())

下一次请求相同资源的时候：

1. 调用 Service Worker 的 fetch 事件响应
2. 查看 memory cache
3. 查看 disk cache, 这里细分为:

- 有强缓存且未失效，则是用强缓存，不请求服务器，返回的状态码都是 200
- 有强缓存且已失效，使用协商缓存判断， 是返回 304 或者 200

### 缓存策略的实际使用场景

---

#### 不常变化的资源

对于不常变化的资源

```md
Cache-Control: max-age=3153600
```

通常给 Cache-Control 设置一个很大的值（比如一年）, 但是有时候为了解决更新问题，我们需要在文件上添加一个 hash，这样就达到了更改引用 URL 的目的。

#### 常变化的资源

对于经常变化的资源

```md
Cache-Control: no-cache
```

我们可以不使用强缓存，每次都向浏览器发送请求，然后配合 `ETag` 或者 `Last-Modified` 来验证资源缓存是否有效

## 聊聊如何搭建高性能网站

在开发中经常会遇到网站的性能瓶颈，打开慢的情况。我们平常开发中应该怎么一步步排查这些问题并解决呢？

> 在快节奏的时代中，慢是个不容忍受的事情。

### 为什么会「慢」

慢的情况多种多样，例如：

1. 用户体验差，感觉慢
2. JS 执行慢
3. 接口响应慢
4. 资源加载慢
5. 浏览器渲染慢

**反正一定是我们的问题，不能是用户的问题。**

### 排查手段

---

#### 技术上的选择

在日常开发中，技术上的选择是非常重要的

为什么要说这个，因为现象频发。前端工程化严重的当下，轻量化的框架逐渐被遗忘，然而并不是所有业务场景都适合使用工程化框架，react/vue 并不轻量

> 复杂的框架是为了解决复杂的业务场景。

如果只是研发宣发、展示等场景简单的业务场景时，原生开发配合一些轻量化的插件更合适

多页面应用也并不都是缺点，根据业务场景选择不一样的技术都是非常重要的，是每个前端都应该反思的事情

这方面也是导致卡顿的关键问题。

#### NetWork

[![pSSXaH1.png](https://s1.ax1x.com/2022/12/29/pSSXaH1.png)](https://imgse.com/i/pSSXaH1)

从 network 面板可以看到一些信息

- 请求资源 size
- 请求资源时长
- 请求资源数量
- 接口响应时长
- 接口发起数量
- 接口报文 size
- 接口响应状态
- 瀑布图

瀑布图就是上方图片后面的 waterfall 纵列

瀑布图是一个级联图，展示了浏览器如何加载资源并渲染页面。图中的每一行都是一次单独的浏览器请求。这个图越长，说明加载网页过程中所发的请求越多。每一行的宽度，代表浏览器发出请求并下载该资源的过程中所耗费的时间，它的侧重点在于分析网路链路。

瀑布图颜色说明：

- **DNS Lookup 【深绿色】：** 在浏览器和服务器通信之前，必须经过 DNS 查询，将域名转换成 IP 地址，在这个阶段你可以处理的东西很少。但幸运的是，并非所有请求都需要经过这一步。

- **Initial Connection 【橙色】：** 在浏览器发送请求之前，必须建立 TCP 连接。这个过程仅仅发生在瀑布图中的开头几行，否则这就是个性能问题。

- **SSL / TLS Negotiation【紫色】：** 如果你的页面是通过 SSL / TLS 这类安全协议加载资源，这段时间就是浏览器建立安全连接的过程。目前 Google 将 HTTPS 作为其搜索排名因素之一，SSL / TLS 协议的使用变得越来越普遍。

- **Time To First Byte（TTFB）【绿色】：** TTFB 是浏览器请求发送到服务器的时间 + 服务器处理请求时间 + 响应报文的第一字节到达浏览器的时间。我们用这个指标来判断你的 web 服务器是否性能不够，或者你是否需要 CDN。

- **Downloading【蓝色】 ：** 这是浏览器用来下载资源所用时间。这段时间越长，说明资源越大。理想情况下，你可以通过控制资源的大小来控制这段时间的长度。

那么除了瀑布图的长度外，我们如何才能判断一个瀑布图的状态是 **健康** 的呢？

- 首先，减少所有资源的加载时间，即减小瀑布图的宽度。瀑布图越窄，网站的访问速度越快。
- 其次，减少请求数量，也就是降低瀑布图的高度，瀑布图越矮越好。
- 最后，通过优化资源请求顺序来加快渲染时间。从图上看，就是将绿色的「开始渲染」线左移，这条线向左移动的越远远好。

这样我们就可以从 Network 角度去排查「慢」的问题。

#### webpack-bundle-analyzer

#### Performance

Chrome 自带的 performance 模块，先附上一个官网文档传送门：[Performance](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/?utm_source=devtools)。

可以检测出很多方面的问题，多数情况的性能排查上用的比较多，如果想要深入了解的同学可以看一下官方文档。

我们来看一下 performance 面板能够为我们提供什么信息：

[![pSSXaH1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3027b177f77f49e3866eeecedefaa70b~tplv-k3u1fbpfcp-zoom-1.image?imageslim)](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3027b177f77f49e3866eeecedefaa70b~tplv-k3u1fbpfcp-zoom-1.image?imageslim)

从上图中我们可以分析出一些指标

- FCP / LCP 时间是否过长
- 请求并发情况，是否并发频繁
- 请求发起顺序是否不对
- JavaScript 执行是否过慢

这些指标是我们需要重点关注的，当然 performance 的功能不止于此。

#### 抓包

有一些业务状况是没有上述的一些调试工具的，此时我们可以利用抓包工具进行对页面信息的抓取，这里我推荐一款抓包工具 [charles](https://www.charlesproxy.com/) 。使用教程网上很多，自行搜索即可。

### 优化指标

这里我们讲一下如何优化上述指标和一些导致满的情况。

#### tree shaking

摇树是 webpack 构建优化中重要的一环，主要用于清除我们项目中一些无用代码，它依赖于 ES 中的模块语法。

比如日常使用 lodash 的时候

```js
import _ from "lodash";
```

如果如上引用 lodash 库，在构建包的时候是会把整个 lodash 包打入到我们的 bundle 包中的。

```js
import _isEmpty from "lodash/isEmpty";
```

如果如上引用 lodash 库，在构建包的时候只会把 isEmpty 这个方法抽离出来再打入到我们的 bundle 包中。

这样的化就会大大减少我们包的 size。所以在日常引用第三方库的时候，需要注意导入的方式。

在 Webpack 4.x 中只需要 mode 换成 production 即可默认开启摇树。

#### split chunks

拆包。

在没有配置任何东西的情况下，webpack 4 就能只能帮你做代码切割。入口文件依赖的文件都被打包到 main.js ，而那些大于 30kb 的第三方依赖都会被打包到 vendors 中。

其他被我们设置了一步加载的页面或者组件也会变成一个个 chunk，也就是被打包成一个个独立的 bundle。

它内置的代码分割策略大致如下：

1. 新的 chunk 是否被共享或者是否来自 node_modules
2. 新的 chunk 提及在压缩之前是否大于 30kb
3. 按需加载 chunk 的并发请求数量小于等于 5 个
4. 页面初始加载时的并发请求数量小于等于 5 个

同时，我们在打包过程中，对于一些不太会变动的第三方依赖，可以选择不将它们打包进来，而是采用 CDN 的方式，这样既加快了打包速度，也可以充分利用缓存提高加载速度。

#### gzip

服务端配置 gzip 压缩后可以大大缩减资源的大小，从而达到加载速度的提升。

#### 图片压缩

开发中比较重要的一个环节，因为设备像素点的关系，UI 给予的图片一般都是 x2，x4 的，所以压缩就非常有必要。

#### 图片分割

如果页面中有一张效果图，比如真机渲染图，UI 手拿着刀不让你压缩。这时候不妨考虑一下分割图片。

建议单张土图片的大小不要超过 100k，我们在分割完图片后，通过布局再拼接在一起。可以图片加载效率。

这里注意一点，分割后的每张图片一定要给高度，否则网速慢的情况下样式会塌陷。

#### sprite

雪碧图，通过将多个小图标合并成一张大图片，从而减少请求数量达到加快加载速度的方法。

目前随着 HTTP/2 的推动，已经不需要这种方式了。

#### CDN

内容分发网络，将资源分发到多台不同的服务器上，这样客户端请求的时候直接请求距离最近的服务器，从而让资源加载速度变快。

#### 懒加载

在长网页中，例如购物网站，当资源没有滚动到可视区域的时候，不选择加载，可以减少客户端渲染的压力。

#### 逻辑后移

逻辑后移是一种比较常见的优化手段。用一个打开文章网站的操作来举个例子。

没有逻辑后移处理的请求顺序是这个样子的

[![-zoom-1.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f8e43dbe2345af85aa232e59a79fc1~tplv-k3u1fbpfcp-zoom-1.image)](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f8e43dbe2345af85aa232e59a79fc1~tplv-k3u1fbpfcp-zoom-1.image)

页面的展示主体是文章展示，如果文章展示的请求靠后了，那么渲染文章出来的时间必然靠后，因为有可能因为请求阻塞等情况，影响请求响应情况，如果超过一次并发的情况的话，会更加的慢。如图的这种情况也是在我们项目中发生过的。

很明显我们应该把主体“请求文章”接口前移，把一些非主体的请求逻辑后移。这样的话可以尽快的把主体渲染出来，就会快很多。

优化后的顺序是这个样子的。

[![-zoom-2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d161a61ec94d42ed9b48cf3b00eb12fa~tplv-k3u1fbpfcp-zoom-1.image)](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d161a61ec94d42ed9b48cf3b00eb12fa~tplv-k3u1fbpfcp-zoom-1.image)

在平常的开发中建议时常注意逻辑后移的情况，突出主体逻辑。可以极大的提升用户体验。

#### 算法复杂度

在数据量大的应用场景中，需要着重注意算法复杂度问题。

如上面 Performance 解析出的 Javascript 执行指标上，可以推测出来你的代码执行效率如何，如果执行时间过长就要考虑一下是否要优化一下复杂度了。

> 在时间换空间，空间换时间的选择上，要根据业务场景来进行取舍。

#### 组件渲染

拿 react 举例，组件分割方面不要太深。需要控制组件的渲染，尤其是深层组件的 render。

老生常谈的话题，我们可以一些方式来优化组件渲染

- 声明周期控制：比如 react 的 shouldComponentUpdate 来控制组件渲染
- 官网提供的 api：PureComponent
- 控制注入组件的参数
- 分配组件唯一 key

没有必要的渲染是对性能的极大浪费。

#### node middleware

中间件。

中间件主要是指封装所有 Http 请求细节处理的方法。一次 Http 请求通常包含很多工作，如记录日志、ip 过滤、查询字符串、请求体解析、Cookie 处理、权限验证、参数验证、异常处理等，但对于 Web 应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让我们能够关注在业务的开发上，以达到提升开发效率的目的。

使用 node middleware 合并请求。减少请求次数。这种方式也是非常实用的。

#### Web Worker

Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢

#### 缓存

充分利用缓存，达到根本不需要请求。
