## 常见的内存泄漏

```md
1. 不正当的闭包
2. 隐式全局变量
3. 脱离DOM引用
4. 遗忘的定时器: setTimeout setInterval
5. 遗忘的事件监听器 addEventListener('scroll') removeEventListener('scroll')
6. 遗忘的监听器模式(Event Bus)
7. 注意Set, Map等强引用类型
```

## js垃圾回收机制

### js垃圾回收算法

引用计算 和 标记清除

#### 1. 引用计算

```js
对象有没有被其他所引用, 如果没有指向该对象（零引用）, 对象将会被垃圾回收。
它的策略就是跟踪记录每个变量值被使用的次数.

1. 当声明一个变量，并且将引用类型的值赋值给这个变量，那么这个值的引用次数为1
2. 如果同一个值又被赋值到另一个变量上面，那么引用次数+1
3. 如果该变量的值被其他值覆盖，则-1
4. 直到该值的引用次数为0的时候，说明没有变量使用，这个值也没法被访问了，垃圾回收器执行时，会清除掉该值
```
**问题**

循环引用

```js
function test() {
    let A = new Object()
    let B = new Object()
    A.a = B
    B.a = A
}
```

##### 优点

1. 清晰很多，当引用次数为0的时候，就会被清除掉
2. **标记清除**需要每隔一段时间进行一次，在程序中线程就必须要暂停去执行一段时间的`GC`
3. **标记清除**需要遍历`堆`里的活动和非活动来清除, 而**引用计数**只需要计算引用次数就行

##### 缺点

1. 需要一个计算器，计算器占很大的空间，因为无法确定引用数量的上限
2. 无法解决循环引用无法回收的问题

#### 标记清除

`标记清除(Mark-Sweep)`, 目前在`js`引擎中最常用的算法

此算法分为`标记`和`清除`两个阶段：

1. 标记阶段为所有的活动对象做上标记
2. 清除阶段则没有标记（也就是非活动对象）销毁

引擎在执行`GC`时，需要从出发点遍历内存中的所有的对象去打标记，而这个出发点很多，可以称为一组`根`对象，
而所有的`根`对象，其实在浏览器环境中包括又不止于`window对象`, `文档DOM树`等

1. 垃圾收集器在运行时会给内存中的所有的对象都加上一个标记, 假设内存中所有对象都是垃圾，全标记为0
2. 然后从各个`根`对象开始遍历, 销毁并回收它们所占用的内存空间
3. 最后把所有内存中的对象标记修改为0,等待下一轮垃圾回收

##### 优点

打标记就是“打”与“不打”两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单

##### 缺点

1. 在清除后，剩余的对象内存位置是不变的，也就会导致空闲内存空间不连续，出现了`内存碎片`
2. 并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表, 这就牵扯到了内存分配到问题


